name: Staff Admin

on:
  workflow_dispatch:
    inputs:
      action:
        description: "Action"
        required: true
        type: choice
        options: [list, create, update, delete]
      username:
        description: "Username (create/update/delete)"
        required: false
      password:
        description: "Password (create/update; optional for update)"
        required: false
      displayName:
        description: "Display name (create/update)"
        required: false
      role:
        description: "Role (staff/officer) for create/update"
        required: false

permissions:
  contents: write

jobs:
  run:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Validate required secrets
        env:
          GAS_ENDPOINT: ${{ secrets.GAS_ENDPOINT }}
          GAS_SECRET: ${{ secrets.GAS_SECRET }}
          GAS_ADMIN_KEY: ${{ secrets.GAS_ADMIN_KEY }}
        run: |
          set -euo pipefail
          test -n "$GAS_ENDPOINT"  || (echo "GAS_ENDPOINT missing" && exit 1)
          test -n "$GAS_SECRET"    || (echo "GAS_SECRET missing" && exit 1)
          test -n "$GAS_ADMIN_KEY" || (echo "GAS_ADMIN_KEY missing" && exit 1)

          # Must be a Web App exec URL, not a Drive/script editor URL.
          if ! echo "$GAS_ENDPOINT" | grep -Eq '^https://script\.google\.com/macros/s/[^/]+/exec$'; then
            echo "ERROR: GAS_ENDPOINT must be the Apps Script Web App exec URL."
            echo "Expected: https://script.google.com/macros/s/<DEPLOYMENT_ID>/exec"
            echo "Got:      $GAS_ENDPOINT"
            exit 1
          fi

      - name: Validate inputs
        env:
          ACTION:   ${{ github.event.inputs.action }}
          USERNAME: ${{ github.event.inputs.username }}
          PASSWORD: ${{ github.event.inputs.password }}
          DISPLAY:  ${{ github.event.inputs.displayName }}
          ROLE:     ${{ github.event.inputs.role }}
        run: |
          set -euo pipefail
          require() { local v="$1"; local name="$2"; test -n "$v" || (echo "$name is required for action=$ACTION" && exit 1); }

          case "$ACTION" in
            list)
              ;;
            create)
              require "$USERNAME" "username"
              require "$PASSWORD" "password"
              require "$DISPLAY"  "displayName"
              require "$ROLE"     "role"
              if [[ "$ROLE" != "staff" && "$ROLE" != "officer" ]]; then
                echo "role must be 'staff' or 'officer'"; exit 1
              fi
              ;;
            update)
              require "$USERNAME" "username"
              if [[ -z "$PASSWORD" && -z "$DISPLAY" && -z "$ROLE" ]]; then
                echo "update requires at least one of: password, displayName, role"; exit 1
              fi
              if [[ -n "$ROLE" && "$ROLE" != "staff" && "$ROLE" != "officer" ]]; then
                echo "role must be 'staff' or 'officer'"; exit 1
              fi
              ;;
            delete)
              require "$USERNAME" "username"
              ;;
            *)
              echo "Unknown action: $ACTION"; exit 1
              ;;
          esac

      - name: Build request body
        env:
          SECRET:   ${{ secrets.GAS_SECRET }}
          ADMINKEY: ${{ secrets.GAS_ADMIN_KEY }}
          ACTION:   ${{ github.event.inputs.action }}
          USERNAME: ${{ github.event.inputs.username }}
          PASSWORD: ${{ github.event.inputs.password }}
          DISPLAY:  ${{ github.event.inputs.displayName }}
          ROLE:     ${{ github.event.inputs.role }}
        run: |
          set -euo pipefail
          case "$ACTION" in
            list)
              jq -n --arg s "$SECRET" --arg k "$ADMINKEY" \
                '{secret:$s, action:"admin.staff:list", adminKey:$k}' > body.json
              ;;
            create)
              jq -n --arg s "$SECRET" --arg k "$ADMINKEY" --arg u "$USERNAME" --arg p "$PASSWORD" --arg d "$DISPLAY" --arg r "$ROLE" \
                '{secret:$s, action:"admin.staff:create", adminKey:$k, username:$u, password:$p, displayName:$d, role:$r}' > body.json
              ;;
            update)
              jq -n --arg s "$SECRET" --arg k "$ADMINKEY" --arg u "$USERNAME" --arg p "$PASSWORD" --arg d "$DISPLAY" --arg r "$ROLE" \
                '{secret:$s, action:"admin.staff:update", adminKey:$k, username:$u, displayName:$d, role:$r, newPassword:$p}' > body.json
              ;;
            delete)
              jq -n --arg s "$SECRET" --arg k "$ADMINKEY" --arg u "$USERNAME" \
                '{secret:$s, action:"admin.staff:delete", adminKey:$k, username:$u}' > body.json
              ;;
          esac

      - name: Call Apps Script
        id: call
        env:
          ENDPOINT: ${{ secrets.GAS_ENDPOINT }}
        run: |
          set -euo pipefail
          echo "jq version: $(jq --version)"
          echo "Calling: $ENDPOINT"

          CODE=$(curl -sS -L -o resp.txt -w "%{http_code}" \
            -H 'Content-Type: text/plain;charset=utf-8' \
            --data @body.json \
            "$ENDPOINT")

          CT=$(file -b --mime-type resp.txt || true)
          echo "HTTP $CODE (mime: $CT)"
          echo "Response (first 40 lines):"
          sed -n '1,40p' resp.txt || true
          echo

          test "$CODE" = "200"

          # If we got HTML, it's usually the wrong endpoint or a redirect to Drive.
          if grep -qi '<!DOCTYPE html' resp.txt; then
            echo "ERROR: Response is HTML. GAS_ENDPOINT is likely not the Web App /exec URL."
            exit 1
          fi

          jq -e '.ok == true' resp.txt > /dev/null
          jq . resp.txt

      - name: Fetch staff list for public/staff.json
        id: staff
        env:
          ENDPOINT: ${{ secrets.GAS_ENDPOINT }}
          SECRET:   ${{ secrets.GAS_SECRET }}
          ADMINKEY: ${{ secrets.GAS_ADMIN_KEY }}
        run: |
          set -euo pipefail
          jq -n --arg s "$SECRET" --arg k "$ADMINKEY" \
            '{secret:$s, action:"admin.staff:list", adminKey:$k}' > staff_body.json

          CODE=$(curl -sS -L -o staff_resp.txt -w "%{http_code}" \
            -H 'Content-Type: text/plain;charset=utf-8' \
            --data @staff_body.json \
            "$ENDPOINT")

          echo "HTTP $CODE (staff list)"
          sed -n '1,40p' staff_resp.txt || true
          echo
          test "$CODE" = "200"
          jq -e '.ok == true' staff_resp.txt > /dev/null

      - name: Generate public/staff.json
        run: |
          set -euo pipefail
          mkdir -p public

          # Portable lower() for jq versions without ascii_downcase.
          jq '
            def lower:
              tostring
              | explode
              | map(if . >= 65 and . <= 90 then . + 32 else . end)
              | implode;

            ( .data.staff // .staff // .data // [] )
            | map(
                if type == "object" then
                  {
                    username: ( .username // .login // .user // "" | lower ),
                    email: ( .email // "" | lower ),
                    role: ( .role // "" ),
                    displayName: ( .displayName // .display_name // .fullName // .full_name // .name // "" )
                  }
                elif type == "string" then
                  if test("@") then
                    { email: ( . | lower ), displayName: . }
                  else
                    { username: ( . | lower ), displayName: . }
                  end
                else empty end
              )
            | map(
                if ((.displayName // "") | tostring | length) == 0 then
                  .displayName = ( .username // .email // "" )
                else . end
              )
            | map( with_entries( select(.value != "" and .value != null) ) )
          ' staff_resp.txt > public/staff.json

          echo "Generated public/staff.json:"
          cat public/staff.json

      - name: Commit staff.json if changed
        run: |
          set -euo pipefail
          if git diff --quiet -- public/staff.json; then
            echo "No changes in public/staff.json"
            exit 0
          fi

          git config user.name  "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add public/staff.json
          git commit -m "chore(staff): update staff.json from '${{ github.event.inputs.action }}'"
          git push
